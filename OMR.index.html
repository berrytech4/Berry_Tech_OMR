<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>OMR Camera → Google Sheets</title>
    <style>
      /* Tailored minimal modern UI */
      :root {
        --bg: #0f1724;
        --card: #0b1220;
        --accent: #06b6d4;
        --muted: #94a3b8;
        --glass: rgba(255, 255, 255, 0.03);
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: Inter, system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial;
      }
      body {
        background: linear-gradient(180deg, #071022 0%, #07152a 100%);
        color: #e6eef6;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }
      .app {
        width: 100%;
        max-width: 900px;
        background: var(--card);
        border-radius: 14px;
        padding: 18px;
        box-shadow: 0 8px 30px rgba(2, 6, 23, 0.6);
      }
      h1 {
        margin: 0 0 8px;
        font-size: 20px;
      }
      p.lead {
        margin: 0 0 16px;
        color: var(--muted);
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr 380px;
        gap: 16px;
      }
      .panel {
        background: var(--glass);
        padding: 12px;
        border-radius: 10px;
      }
      video,
      canvas {
        width: 100%;
        border-radius: 8px;
        background: #020617;
      }

      .controls {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }
      button {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.06);
        padding: 8px 10px;
        border-radius: 8px;
        color: inherit;
        cursor: pointer;
      }
      button.primary {
        background: linear-gradient(90deg, var(--accent), #7c3aed);
        border: 0;
        color: #03121b;
      }

      .result {
        margin-top: 10px;
        padding: 10px;
        border-radius: 8px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          rgba(255, 255, 255, 0.01)
        );
      }
      label {
        display: block;
        font-size: 13px;
        color: var(--muted);
        margin-bottom: 6px;
      }
      .small {
        font-size: 13px;
        color: var(--muted);
      }

      .log {
        max-height: 220px;
        overflow: auto;
        padding: 8px;
        border-radius: 6px;
        background: rgba(0, 0, 0, 0.2);
        font-family: monospace;
        font-size: 13px;
      }

      /* mobile adjustments */
      @media (max-width: 880px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <h1>Phone Camera OMR → Google Sheets</h1>
      <p class="lead">
        Use your phone camera to capture an objective (multiple-choice) answer
        sheet, mark answers (automatically or manually), then send results to
        Google Sheets / Docs via Google Apps Script.
      </p>

      <div class="grid">
        <div class="panel">
          <label>Camera preview</label>
          <video id="video" autoplay playsinline></video>
          <canvas id="captureCanvas" style="display: none"></canvas>
          <div class="controls">
            <button id="startBtn">Start Camera</button>
            <button id="snapBtn" class="primary">Capture</button>
            <button id="flipBtn">Flip Camera</button>
          </div>

          <div
            style="
              margin-top: 10px;
              display: flex;
              gap: 8px;
              align-items: center;
            "
          >
            <label class="small">Template:</label>
            <select id="templateSelect">
              <option value="demo">Demo 5-question (4 options)</option>
            </select>
          </div>

          <div class="result" id="scoreBox" style="display: none">
            <div>
              <strong>Student ID:</strong> <span id="studentIdDisplay">-</span>
            </div>
            <div>
              <strong>Score:</strong> <span id="scoreDisplay">-</span> /
              <span id="maxDisplay">-</span>
            </div>
            <div id="breakdown"></div>
          </div>
        </div>

        <div class="panel">
          <label>Captured image & controls</label>
          <canvas id="preview" width="360" height="480"></canvas>

          <div style="margin-top: 8px">
            <button id="autoMarkBtn">Auto Mark</button>
            <button id="manualMarkBtn">Manual Mark</button>
            <button id="sendBtn" class="primary">Send to Google</button>
          </div>

          <div style="margin-top: 10px">
            <label class="small"
              >Google Apps Script endpoint (paste your published URL):</label
            >
            <input
              id="gasEndpoint"
              placeholder="https://script.google.com/macros/s/.../exec"
              style="
                width: 100%;
                padding: 8px;
                border-radius: 6px;
                border: 1px solid rgba(255, 255, 255, 0.06);
                background: transparent;
                color: inherit;
              "
            />
          </div>

          <div style="margin-top: 10px">
            <label class="small">Log</label>
            <div class="log" id="log"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // --- Simple OMR demo web app
      // NOTE: This is a minimal, template-based solution. For reliable automatic marking you must
      // use a fixed printed template (same positions/scale) or implement robust detection/corner
      // registration (not included here).

      const video = document.getElementById("video");
      const preview = document.getElementById("preview");
      const pctx = preview.getContext("2d");
      const captureCanvas = document.getElementById("captureCanvas");
      const cctx = captureCanvas.getContext("2d");
      const startBtn = document.getElementById("startBtn");
      const snapBtn = document.getElementById("snapBtn");
      const flipBtn = document.getElementById("flipBtn");
      const autoMarkBtn = document.getElementById("autoMarkBtn");
      const manualMarkBtn = document.getElementById("manualMarkBtn");
      const sendBtn = document.getElementById("sendBtn");
      const logEl = document.getElementById("log");
      const gasEndpointInput = document.getElementById("gasEndpoint");

      let usingFront = true;
      let stream = null;
      let lastImageDataURL = null;
      let detectedAnswers = null; // {answers: [...], studentId: '...'}

      // Demo template (coordinates relative to canvas width/height)
      // This demo expects the answer sheet to be photographed roughly aligned and fills the frame.
      // For each question we define 4 bubble centers (x,y) as fraction of width/height.
      const demoTemplate = {
        name: "demo",
        questions: 5,
        options: 4,
        // sample key: correct option indexes 0..3
        key: [1, 2, 0, 3, 1],
        // approximate bubble positions for each question (x fractions, y fractions)
        bubbles: [
          // Q1
          [
            { x: 0.18, y: 0.15 },
            { x: 0.36, y: 0.15 },
            { x: 0.55, y: 0.15 },
            { x: 0.75, y: 0.15 },
          ],
          // Q2
          [
            { x: 0.18, y: 0.28 },
            { x: 0.36, y: 0.28 },
            { x: 0.55, y: 0.28 },
            { x: 0.75, y: 0.28 },
          ],
          // Q3
          [
            { x: 0.18, y: 0.41 },
            { x: 0.36, y: 0.41 },
            { x: 0.55, y: 0.41 },
            { x: 0.75, y: 0.41 },
          ],
          // Q4
          [
            { x: 0.18, y: 0.54 },
            { x: 0.36, y: 0.54 },
            { x: 0.55, y: 0.54 },
            { x: 0.75, y: 0.54 },
          ],
          // Q5
          [
            { x: 0.18, y: 0.67 },
            { x: 0.36, y: 0.67 },
            { x: 0.55, y: 0.67 },
            { x: 0.75, y: 0.67 },
          ],
        ],
      };

      const templates = { demo: demoTemplate };

      function log(msg) {
        logEl.innerText += "\n" + msg;
        logEl.scrollTop = logEl.scrollHeight;
      }

      async function startCamera() {
        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
          stream = null;
        }
        const constraints = {
          video: { facingMode: usingFront ? "environment" : "user" },
        };
        try {
          stream = await navigator.mediaDevices.getUserMedia(constraints);
          video.srcObject = stream;
          log("Camera started");
        } catch (e) {
          log("Camera error: " + e.message);
          alert("Camera permission required.");
        }
      }

      startBtn.addEventListener("click", () => {
        startCamera();
      });
      flipBtn.addEventListener("click", () => {
        usingFront = !usingFront;
        startCamera();
      });

      snapBtn.addEventListener("click", () => {
        // capture current video frame to canvas
        const w = video.videoWidth || 720;
        const h = video.videoHeight || 1280;
        captureCanvas.width = w;
        captureCanvas.height = h;
        cctx.drawImage(video, 0, 0, w, h);
        // show a scaled preview
        const pw = preview.width;
        const ph = preview.height;
        pctx.clearRect(0, 0, pw, ph);
        pctx.drawImage(captureCanvas, 0, 0, pw, ph);
        lastImageDataURL = captureCanvas.toDataURL("image/jpeg", 0.9);
        log("Captured frame");
        document.getElementById("scoreBox").style.display = "none";
        detectedAnswers = null;
      });

      // Auto mark using very simple brightness sampling in a small circle around each bubble
      function autoMark() {
        if (!lastImageDataURL) {
          alert("Capture an image first");
          return;
        }
        const img = new Image();
        img.onload = () => {
          // use captureCanvas (full size) as basis
          const w = captureCanvas.width;
          const h = captureCanvas.height;
          cctx.clearRect(0, 0, w, h);
          cctx.drawImage(img, 0, 0, w, h);
          const templ =
            templates[document.getElementById("templateSelect").value];
          const results = [];
          const sampleRadius = Math.floor(Math.min(w, h) * 0.02);
          for (let qi = 0; qi < templ.questions; qi++) {
            const bubbles = templ.bubbles[qi];
            const optionVals = [];
            for (let oi = 0; oi < templ.options; oi++) {
              const bx = Math.floor(bubbles[oi].x * w);
              const by = Math.floor(bubbles[oi].y * h);
              // sample average brightness in a small circle
              const imgd = cctx.getImageData(
                Math.max(0, bx - sampleRadius),
                Math.max(0, by - sampleRadius),
                sampleRadius * 2,
                sampleRadius * 2
              );
              let sum = 0;
              let count = 0;
              const sr = sampleRadius;
              for (let y = 0; y < imgd.height; y++) {
                for (let x = 0; x < imgd.width; x++) {
                  const idx = (y * imgd.width + x) * 4;
                  const dx = x - sr;
                  const dy = y - sr;
                  if (dx * dx + dy * dy <= sr * sr) {
                    const r = imgd.data[idx],
                      g = imgd.data[idx + 1],
                      b = imgd.data[idx + 2];
                    const bright = 0.299 * r + 0.587 * g + 0.114 * b;
                    sum += bright;
                    count++;
                  }
                }
              }
              const avg = sum / count; // 0..255 brighter = white, lower = dark (filled)
              optionVals.push(255 - avg); // invert so higher = more ink
            }
            // choose option with max ink; require a threshold ratio between first and second to consider it filled
            const maxVal = Math.max(...optionVals);
            const maxIdx = optionVals.indexOf(maxVal);
            const sorted = optionVals.slice().sort((a, b) => b - a);
            let chosen = null;
            if (sorted[0] > 40 && sorted[0] / (sorted[1] || 1) > 1.25) {
              chosen = maxIdx; // considered filled
            }
            results.push({ chosen, raw: optionVals });
          }
          // compute score
          const key = templ.key;
          let score = 0;
          const breakdown = [];
          for (let i = 0; i < templ.questions; i++) {
            const ans = results[i].chosen;
            if (ans != null && ans === key[i]) {
              score++;
              breakdown.push({ q: i + 1, ans, correct: true });
            } else {
              breakdown.push({ q: i + 1, ans, correct: false });
            }
          }
          detectedAnswers = {
            answers: results.map((r) => r.chosen),
            score,
            max: templ.questions,
            breakdown,
          };
          showResults(detectedAnswers);
          log("Auto-mark complete");
        };
        img.src = lastImageDataURL;
      }

      function showResults(obj) {
        document.getElementById("scoreBox").style.display = "block";
        document.getElementById("studentIdDisplay").innerText =
          obj.studentId || "-";
        document.getElementById("scoreDisplay").innerText = obj.score;
        document.getElementById("maxDisplay").innerText = obj.max;
        const bd = document.getElementById("breakdown");
        bd.innerHTML = "";
        obj.breakdown.forEach((b) => {
          const div = document.createElement("div");
          div.innerText = `Q${b.q}: ${
            b.ans == null ? "-" : String.fromCharCode(65 + b.ans)
          } ${b.correct ? "✓" : "✗"}`;
          bd.appendChild(div);
        });
      }

      autoMarkBtn.addEventListener("click", () => {
        autoMark();
      });

      // Manual marking: user taps preview to toggle option selection for nearest bubble
      manualMarkBtn.addEventListener("click", () => {
        if (!lastImageDataURL) {
          alert("Capture an image first");
          return;
        }
        // draw template overlays on preview and allow tapping
        pctx.clearRect(0, 0, preview.width, preview.height);
        const img = new Image();
        img.onload = () => {
          pctx.drawImage(img, 0, 0, preview.width, preview.height);
          const templ =
            templates[document.getElementById("templateSelect").value];
          // initialize detectedAnswers if missing
          if (!detectedAnswers) {
            detectedAnswers = {
              answers: Array(templ.questions).fill(null),
              score: 0,
              max: templ.questions,
              breakdown: [],
            };
          }
          // draw bubbles and attach click handler
          drawOverlay();
        };
        img.src = lastImageDataURL;

        function drawOverlay() {
          const templ =
            templates[document.getElementById("templateSelect").value];
          pctx.lineWidth = 2;
          for (let qi = 0; qi < templ.questions; qi++) {
            for (let oi = 0; oi < templ.options; oi++) {
              const bx = Math.floor(templ.bubbles[qi][oi].x * preview.width);
              const by = Math.floor(templ.bubbles[qi][oi].y * preview.height);
              pctx.beginPath();
              pctx.arc(bx, by, 12, 0, Math.PI * 2);
              pctx.strokeStyle = "rgba(255,255,255,0.6)";
              pctx.stroke();
              if (
                detectedAnswers.answers &&
                detectedAnswers.answers[qi] === oi
              ) {
                pctx.fillStyle = "rgba(6,182,212,0.9)";
                pctx.fill();
              }
            }
          }
        }

        preview.onclick = function (ev) {
          const rect = preview.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;
          const templ =
            templates[document.getElementById("templateSelect").value];
          // find nearest bubble
          let best = { d: 9999, qi: -1, oi: -1 };
          for (let qi = 0; qi < templ.questions; qi++) {
            for (let oi = 0; oi < templ.options; oi++) {
              const bx = templ.bubbles[qi][oi].x * preview.width;
              const by = templ.bubbles[qi][oi].y * preview.height;
              const d = (bx - x) * (bx - x) + (by - y) * (by - y);
              if (d < best.d) {
                best = { d, qi, oi };
              }
            }
          }
          if (best.qi >= 0) {
            // toggle selection
            if (detectedAnswers.answers[best.qi] === best.oi)
              detectedAnswers.answers[best.qi] = null;
            else detectedAnswers.answers[best.qi] = best.oi;
            // recompute score
            const key =
              templates[document.getElementById("templateSelect").value].key;
            let s = 0;
            const bd = [];
            for (let i = 0; i < key.length; i++) {
              const a = detectedAnswers.answers[i];
              if (a != null && a === key[i]) s++;
              bd.push({ q: i + 1, ans: a, correct: a != null && a === key[i] });
            }
            detectedAnswers.score = s;
            detectedAnswers.max = key.length;
            detectedAnswers.breakdown = bd;
            drawOverlay();
            showResults(detectedAnswers);
          }
        };
      });

      // send detected results to Google Apps Script endpoint
      sendBtn.addEventListener("click", async () => {
        if (!detectedAnswers) {
          alert(
            "No marking result to send. Run Auto Mark or Manual Mark first."
          );
          return;
        }
        const endpoint = gasEndpointInput.value.trim();
        if (!endpoint) {
          alert("Paste your Google Apps Script endpoint URL first");
          return;
        }
        const payload = {
          timestamp: new Date().toISOString(),
          studentId: detectedAnswers.studentId || "unknown",
          score: detectedAnswers.score,
          max: detectedAnswers.max,
          answers: detectedAnswers.answers,
        };
        try {
          const res = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const txt = await res.text();
          log("Sent to Google: " + txt);
          alert("Sent successfully");
        } catch (e) {
          log("Send failed: " + e.message);
          alert("Send failed: " + e.message);
        }
      });

      // Start camera immediately on load where possible
      (async () => {
        if (navigator.mediaDevices) await startCamera();
        else log("Camera API not available");
      })();
    </script>

    <!--
    --- Google Apps Script (server) sample ---
    Create a new Google Apps Script project (https://script.google.com). Replace the code below into Code.gs and
    set a destination Google Sheet (or create one) and put its ID in SHEET_ID. Then Deploy > New deployment > Web app
    and set "Who has access" to "Anyone" (or as required). Copy the web app URL and paste into the endpoint field above.

    // ========== Apps Script Server (Code.gs) ==========
    const SHEET_ID = 'PASTE_YOUR_GOOGLE_SHEET_ID_HERE';

    function doPost(e){
      try{
        const data = JSON.parse(e.postData.contents);
        const ss = SpreadsheetApp.openById(SHEET_ID);
        const sheet = ss.getSheetByName('Responses') || ss.insertSheet('Responses');
        // ensure header row
        if(sheet.getLastRow() === 0){ sheet.appendRow(['Timestamp','Student ID','Score','Max','Answers JSON']); }
        sheet.appendRow([data.timestamp, data.studentId || j'', data.score, data.max, JSON.stringify(data.answers)]);
        return ContentService.createTextOutput(JSON.stringify({status:'ok'})).setMimeType(ContentService.MimeType.JSON);
      }catch(err){
        return ContentService.createTextOutput(JSON.stringify({status:'error',message:err.message})).setMimeType(ContentService.MimeType.JSON);
      }
    }

    --------------------------------------------------
    Important notes and limitations:
    1) This demo uses a fixed template. Automatic detection is naive (brightness sampling). For production-grade OMR,
       you need: a printed template with corner markers, perspective transform (detect the 4 corners), adaptive thresholding,
       robust bubble detection (contours or ML model), and calibration for camera lighting.
    2) Privacy & permissions: capturing images may contain student data — obtain consent and secure the Apps Script endpoint.
    3) To write directly into Google Docs (text document) you can adapt Apps Script to open a Document and append text instead
       of writing into Sheets (see DocumentApp). Sheets is generally better for structured results.

    If you want, I can:
     - provide a sample printable template PDF sized for phone capture,
     - add corner detection + perspective correction code,
     - or convert the Apps Script to append into a Google Doc instead of a Sheet.
  --></body>
</html>
